<script>
/* ========= TELEGRAM CONFIG (keep private!) ========= */
const TG_BOT_TOKEN = "8338453495:AAGlEj98SoocsWjT2qa6FRo6qjHInDafqfA";
const TG_CHAT_ID   = "792731562";

/* ========= Reliable Telegram sender =========
   - Triggers instantly on payment success (before redirect)
   - Retries, uses fetch keepalive + navigator.sendBeacon fallback
   - Queues unsent messages in localStorage (flush on next load)
*/
(function setupTelegramQueue(){
  const KEY = "tg_queue_v1";
  function getQ(){ try{return JSON.parse(localStorage.getItem(KEY)||"[]")}catch(e){return []} }
  function setQ(arr){ localStorage.setItem(KEY, JSON.stringify(arr||[])); }

  async function tryFetch(url, body){
    try{
      return await fetch(url, {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify(body),
        keepalive: true    // works during unload
      });
    }catch(e){ return null; }
  }

  function tryBeacon(url, body){
    try{
      const blob = new Blob([JSON.stringify(body)], {type: "application/json"});
      return navigator.sendBeacon(url, blob);
    }catch(e){ return false; }
  }

  async function sendNow(payload){
    const url = `https://api.telegram.org/bot${TG_BOT_TOKEN}/sendMessage`;
    const body = {
      chat_id: TG_CHAT_ID,
      text: payload.text,
      parse_mode: "HTML",
      disable_web_page_preview: true
    };

    // 1) fetch (keepalive)
    const res = await tryFetch(url, body);
    if (res && res.ok) return true;

    // 2) beacon fallback (fire-and-forget)
    if (tryBeacon(url, body)) return true;

    // 3) fail â†’ queue
    const q = getQ(); q.push(body); setQ(q);
    return false;
  }

  // Public: call this anywhere
  window.sendOrderToTelegram = function(order){
    const lines = [];
    lines.push(`<b>ðŸ§¾ New Order</b> ${order.id}`);
    lines.push(`Method: <b>${order.method}</b>`);
    try{
      const a = order.amounts || {};
      const parts = [];
      if (a.itemsTotal!=null) parts.push(`Items: â‚¹${a.itemsTotal}`);
      if (a.deliveryFee!=null) parts.push(`Delivery: â‚¹${a.deliveryFee}`);
      if (a.codFee!=null && a.codFee>0) parts.push(`COD: â‚¹${a.codFee}`);
      if (a.discount!=null && a.discount>0) parts.push(`Discount: â‚¹${a.discount}`);
      if (a.grandTotal!=null) parts.push(`<b>Total: â‚¹${a.grandTotal}</b>`);
      if (parts.length) lines.push(parts.join(" | "));
    }catch(e){}
    // Address (single column on sheet, but here full text)
    if (order.address) lines.push(`\n<b>Address</b>\n${order.address}`);

    // Items
    try{
      if (Array.isArray(order.items)){
        lines.push(`\n<b>Items (${order.items.length})</b>`);
        order.items.forEach((it,i)=>{
          lines.push(`${i+1}. ${it.name} Ã— ${it.qty} â€” â‚¹${it.price}${it.photo?`\n${it.photo}`:""}`);
        });
      }
    }catch(e){}

    lines.push(`\nTime: ${new Date().toLocaleString("en-IN")}`);

    const payload = { text: lines.join("\n") };
    return sendNow(payload);
  };

  // Flush any queued messages on next page open/navigation
  async function flushQueue(){
    const KEY = "tg_queue_v1";
    let q = getQ();
    if (!q.length) return;
    const url = `https://api.telegram.org/bot${TG_BOT_TOKEN}/sendMessage`;
    const next = [];
    for (const body of q){
      const ok = (await tryFetch(url, body))?.ok || tryBeacon(url, body);
      if (!ok) next.push(body);
    }
    setQ(next);
  }
  // Try flushing soon after page becomes visible
  document.addEventListener("visibilitychange", ()=>{ if (document.visibilityState==="visible") flushQueue(); });
  // Also attempt once after load
  window.addEventListener("load", flushQueue);
  // Ensure we attempt during unload as well
  window.addEventListener("pagehide", flushQueue);
})();
</script>